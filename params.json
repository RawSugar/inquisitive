{"name":"Inquisitive","tagline":"Predicate methods for those curious about their Ruby datastructures.","body":"Inquisitive\r\n===========\r\n\r\n> **Predicate methods for those curious about their datastructures.**\r\n\r\nSynopsis\r\n--------\r\n\r\nInquisitive provides String, Array, and Hash subclasses with dynamic predicate methods that allow you to interrogate the most common Ruby datastructures in a readable, friendly fashion. It's the inevitable evolution of ActiveSupport's [`StringInquirer`](https://github.com/rails/rails/blob/master/activesupport/lib/active_support/string_inquirer.rb).\r\n\r\nIt also allows you to elegantly interrogate your `ENV` hash through the `Inquisitive::Environment` module.\r\n\r\nInquisitive will try to use ActiveSupport's [`HashWithIndifferentAccess`](guides.rubyonrails.org/active_support_core_extensions.html#indifferent-access), but if that cannot be found it will bootstrap itself with a minimal, well-tested version extracted from [ActiveSupport 4.0](https://github.com/rails/rails/blob/4-0-stable/activesupport/lib/active_support/hash_with_indifferent_access.rb).\r\n\r\nInquisitive is tested against all maintained versions of Ruby and ActiveSupport.\r\n\r\n--------------------------------------------------------------------------------\r\n\r\nStatus\r\n------\r\n\r\n[status]:   https://travis-ci.org/christhekeele/inquisitive\r\n[coverage]: https://rawgit.com/christhekeele/inquisitive/master/coverage/index.html\r\n\r\n[version]:       https://rubygems.org/gems/inquisitive/versions\r\n[version-image]: https://badge.fury.io/rb/inquisitive@2x.svg\r\n\r\n[quality]:       https://codeclimate.com/github/christhekeele/inquisitive\r\n[quality-image]: https://img.shields.io/codeclimate/github/christhekeele/inquisitive.svg\r\n\r\n[dependencies]:       https://gemnasium.com/christhekeele/inquisitive\r\n[dependencies-image]: http://img.shields.io/gemnasium/christhekeele/inquisitive.svg\r\n\r\n[master]:          https://github.com/christhekeele/inquisitive/tree/master\r\n[master-status]:   https://img.shields.io/travis/christhekeele/inquisitive/master.svg\r\n[master-coverage]: https://img.shields.io/coveralls/christhekeele/inquisitive/master.svg\r\n\r\n[development]:          https://github.com/christhekeele/inquisitive/tree/development\r\n[development-status]:   https://img.shields.io/travis/christhekeele/inquisitive/development.svg\r\n[development-coverage]: https://img.shields.io/coveralls/christhekeele/inquisitive/development.svg\r\n\r\n[![Version][version-image]][version] [![Quality][quality-image]][quality] [![Dependencies][dependencies-image]][dependencies]\r\n\r\n|         :thumbsup:         |  [Continuous Integration][status]   |        [Test Coverage][coverage]         |\r\n|:--------------------------:|:-----------------------------------:|:----------------------------------------:|\r\n|      [Master][master]      |   ![Build Status][master-status]    |   ![Coverage Status][master-coverage]    |\r\n| [Development][development] | ![Build Status][development-status] | ![Coverage Status][development-coverage] |\r\n\r\n--------------------------------------------------------------------------------\r\n\r\nInstallation\r\n------------\r\n\r\nTo add to your project:\r\n\r\n```bash\r\n$ echo \"gem 'inquisitive'\" >> Gemfile\r\n$ bundle install\r\n```\r\n\r\nOtherwise:\r\n\r\n```bash\r\n$ gem install inquisitive\r\n```\r\n\r\n--------------------------------------------------------------------------------\r\n\r\nUsage\r\n-----\r\n\r\n\r\n### Helpers\r\n\r\nYou can coerce any object to a supported Inquisitive equivalent with the Inquisitive coercion helpers:\r\n\r\n```ruby\r\nInquisitive.coerce('foo').class\r\n#=> Inquisitive::String\r\nInquisitive.coerce(1).class\r\n#=> Integer\r\n\r\nInquisitive['foo'].class\r\n#=> Inquisitive::String\r\nInquisitive[1].class\r\n#=> Integer\r\n\r\nInquisitive.coerce!('foo').class\r\n#=> Inquisitive::String\r\nInquisitive.coerce!(1).class\r\n#=> NameError\r\n```\r\n\r\nYou can check if any object appears to be present with the Inquisitive presence helper:\r\n\r\n```ruby\r\nInquisitive.present? 'foo'\r\n#=> true\r\nInquisitive.present? %i[foo]\r\n#=> true\r\nInquisitive.present? {foo: :bar}\r\n#=> true\r\nInquisitive.present? 0\r\n#=> true\r\nInquisitive.present? true\r\n#=> true\r\n\r\nInquisitive.present? ''\r\n#=> false\r\nInquisitive.present? Array.new\r\n#=> false\r\nInquisitive.present? Hash.new\r\n#=> false\r\nInquisitive.present? false\r\n#=> false\r\nInquisitive.present? nil\r\n#=> false\r\nInquisitive.present? Inquisitive::NilClass.new\r\n#=> false\r\n```\r\n\r\nFinally, you can check if any object is explicitly an Inquisitive object with the Inquisitive object helper:\r\n\r\n```ruby\r\nnil_object = nil\r\nInquisitive.object? nil_object\r\n#=> false\r\nInquisitive.object? Inquisitive[nil_object]\r\n#=> true\r\nInquisitive.object? Inquisitive::NilClass.new nil_object\r\n#=> true\r\n\r\nstring = 'foo'\r\nInquisitive.object? string\r\n#=> false\r\nInquisitive.object? Inquisitive[string]\r\n#=> true\r\nInquisitive.object? Inquisitive::String.new string\r\n#=> true\r\n\r\narray = %i[foo]\r\nInquisitive.object? array\r\n#=> false\r\nInquisitive.object? Inquisitive[array]\r\n#=> true\r\nInquisitive.object? Inquisitive::Array.new array\r\n#=> true\r\n\r\nhash = {foo: :bar}\r\nInquisitive.object? hash\r\n#=> false\r\nInquisitive.object? Inquisitive[hash]\r\n#=> true\r\nInquisitive.object? Inquisitive::Hash.new hash\r\n#=> true\r\n```\r\n\r\n\r\n### String\r\n\r\n`Inquisitive::String` tests equality:\r\n\r\n```ruby\r\nenvironment = Inquisitive::String.new 'development'\r\n#=> \"development\"\r\nenvironment.development?\r\n#=> true\r\nenvironment.not.development?\r\n#=> false\r\n```\r\n\r\n\r\n### Array\r\n\r\n`Inquisitive::Array` tests inclusion:\r\n\r\n```ruby\r\nsupported_databases = Inquisitive::Array.new %w[mysql postgres sqlite]\r\n#=> [\"mysql\", \"postgres\", \"sqlite\"]\r\nsupported_databases.postgres?\r\n#=> true\r\nsupported_databases.sql_server?\r\n#=> false\r\nsupported_databases.exclude.sql_server?\r\n#=> true\r\n```\r\n\r\n\r\n### Hash\r\n\r\n`Inquisitive::Hash` provides struct-like access to its values, wrapped in other inquisitive objects:\r\n\r\n```ruby\r\nstubbed = Inquisitive::Hash.new(\r\n  authentication: true,\r\n  in: 'development',\r\n  services: %w[database api],\r\n  api: {protocol: 'https', subdomains: %w[app web db]},\r\n  ignorable: { junk: [ '' ] }\r\n)\r\n#=> {\"authentication\"=>true,\r\n#=>  \"in\"=>\"development\",\r\n#=>  \"services\"=>[\"database\", \"api\"],\r\n#=>  \"api\"=>{\"protocol\"=>\"https\", \"subdomains\"=>[\"app\", \"web\", \"db\"]},\r\n#=>  \"ignorable\"=>{\"junk\"=>[\"\"]}}\r\n\r\nstubbed.authentication?\r\n#=> true\r\nstubbed.registration?\r\n#=> false\r\nstubbed.services?\r\n#=> true\r\nstubbed.api?\r\n#=> true\r\nstubbed.ignorable?\r\n#=> false\r\n\r\nstubbed.in.development?\r\n#=> true\r\nstubbed.in.production?\r\n#=> false\r\n\r\nstubbed.services.database?\r\n#=> true\r\nstubbed.services.sidekiq?\r\n#=> false\r\n\r\nstubbed.api.protocol?\r\n#=> true\r\nstubbed.api.protocol.http?\r\n#=> false\r\nstubbed.api.domains.web?\r\n#=> true\r\n```\r\n\r\n`Inquisitive::Hash` also allows negation with the `no` method:\r\n\r\n```ruby\r\nconfig = Inquisitive::Hash.new(database: 'postgres')\r\n#=> {\"database\"=>\"postgres\"}\r\n\r\nconfig.database?\r\n#=> true\r\nconfig.no.database?\r\n#=> false\r\nconfig.api?\r\n#=> false\r\nconfig.no.api?\r\n#=> true\r\n```\r\n\r\nEmpty keys and nil values become instances of `Inquisitive::NilClass`, which is a black-hole null object that respects the Inquisitive interface, allowing you to inquire on non-existant nested datastructures as if there was one there, negated methods included:\r\n\r\n```ruby\r\nstubbed = Inquisitive::Hash.new\r\n#=> {}\r\n\r\n# We can query it as if we assumed we had:\r\n#=> {\"authentication\"=>true,\r\n#=>  \"in\"=>\"development\",\r\n#=>  \"services\"=>[\"database\", \"api\"],\r\n#=>  \"api\"=>{\"protocol\"=>\"https\", \"subdomains\"=>[\"app\", \"web\", \"db\"]}}\r\n\r\nstubbed.authentication?\r\n#=> false\r\nstubbed.registration?\r\n#=> false\r\nstubbed.services?\r\n#=> false\r\nstubbed.api?\r\n#=> false\r\nstubbed.ignorable?\r\n#=> false\r\nstubbed.no.ignorable?\r\n#=> true\r\n\r\nstubbed.in.development?\r\n#=> false\r\nstubbed.in.production?\r\n#=> false\r\nstubbed.in.not.production?\r\n#=> true\r\n\r\nstubbed.services.database?\r\n#=> false\r\nstubbed.services.sidekiq?\r\n#=> false\r\nstubbed.services.exclude.sidekiq?\r\n#=> true\r\n\r\nstubbed.api.protocol?\r\n#=> false\r\nstubbed.api.no.protocol?\r\n#=> true\r\nstubbed.api.protocol.http?\r\n#=> false\r\nstubbed.api.domains.web?\r\n#=> false\r\n```\r\n\r\nThis custom `Inquisitive::NilClass` comes with a few caveats, read the section below to understand them.\r\n\r\n\r\n### NilClass\r\n\r\n`Inquisitive::NilClass` is a black-hole null object that respects the Inquisitive interface, allowing you to inquire on non-existant nested datastructures as if there was one there, negated methods included:\r\n\r\n```ruby\r\nnillish = Inquisitive::NilClass.new\r\n#=> nil\r\n\r\nnillish.nil?\r\n#=> true\r\nnillish.present?\r\n#=> false\r\n\r\n\r\nnillish.predicate?\r\n#=> false\r\nnillish.access\r\n#=> nil\r\nnillish.deep.access\r\n#=> nil\r\nnillish.not.access\r\n#=> true\r\nnillish.exclude.access\r\n#=> true\r\nnillish.no.access\r\n#=> true\r\n```\r\n\r\n**Be warned**: since Ruby doesn't allow subclassing `NilClass` and provides no boolean-coercion interface, `Inquisitive::NilClass` **will** appear truthy. I recommend using built-in predicates (`stubbed.authentication? && ...`), presence predicates with ActiveSupport (`stubbed.authentication.present? && ...`), Inquisitive's presence utility (`Inquisitive.present?(stubbed.authentication) && ...`) or nil predicates (`stubbed.authentication.nil? || ...`) in boolean chains. Also note that for `Inquisitive::Hash` access, `stubbed.fetch(:authentication, ...)` behaves as expected.\r\n\r\n\r\n### Inquisitive Environment\r\n\r\n`Inquisitive::Environment` can be used in your modules and classes to more easily interrogate `ENV` variables with inquisitive objects:\r\n\r\n#### Strings\r\n\r\n```ruby\r\nENV['ENVIRONMENT'] = 'development'\r\nclass MyApp\r\n  extend Inquisitive::Environment\r\n  inquires_about 'ENVIRONMENT'\r\nend\r\n\r\nMyApp.environment\r\n#=> \"development\"\r\nMyApp.environment.development?\r\n#=> true\r\nMyApp.environment.production?\r\n#=> false\r\n```\r\n\r\n#### Arrays\r\n\r\nArrays are recognized when environment variables contain commas:\r\n\r\n```ruby\r\nENV['SUPPORTED_DATABASES'] = 'mysql,postgres,sqlite'\r\nclass MyApp\r\n  extend Inquisitive::Environment\r\n  inquires_about 'SUPPORTED_DATABASES'\r\nend\r\n\r\nMyApp.supported_databases\r\n#=> [\"mysql\", \"postgres\", \"sqlite\"]\r\nMyApp.supported_databases.sqlite?\r\n#=> true\r\nMyApp.supported_databases.sql_server?\r\n#=> false\r\n```\r\n\r\n#### Hashes\r\n\r\nHashes are recognized when environment variables names contain double underscores:\r\n\r\n```ruby\r\nENV['STUB__AUTHENTICATION']  = 'true'\r\nENV['STUB__IN']              = 'development'\r\nENV['STUB__SERVICES']        = 'database,api'\r\nENV['STUB__API__PROTOCOL']   = 'https'\r\nENV['STUB__API__SUBDOMAINS'] = 'app,web,db'\r\nclass MyApp\r\n  extend Inquisitive::Environment\r\n  inquires_about 'STUB'\r\nend\r\n\r\nMyApp.stub.authentication?\r\n#=> true\r\nMyApp.stub.registration?\r\n#=> false\r\nMyApp.stub.in.development?\r\n#=> true\r\nMyApp.stub.in.production?\r\n#=> false\r\nMyApp.stub.services.exclude.sidekiq?\r\n#=> true\r\nMyApp.stub.services.sidekiq?\r\n#=> false\r\nMyApp.stub.api.protocol.http?\r\n#=> false\r\nMyApp.stub.api.subdomains.web?\r\n#=> true\r\n```\r\n\r\n#### Defaults\r\n\r\nYou can set default values for your environment inquirers.\r\n\r\n```ruby\r\nclass MyApp\r\n  extend Inquisitive::Environment\r\n  inquires_about 'ENV', default: 'production'\r\nend\r\n\r\nMyApp.env?\r\n#=> true\r\nMyApp.env.production?\r\n#=> true\r\n```\r\n\r\n#### Naming\r\n\r\nYou can also give your environment inquirers custom names:\r\n\r\n```ruby\r\nENV['ENVIRONMENT'] = 'development'\r\nclass MyApp\r\n  extend Inquisitive::Environment\r\n  inquires_about 'ENVIRONMENT', with: :env\r\nend\r\n\r\nMyApp.env\r\n#=> \"development\"\r\nMyApp.env.development?\r\n#=> true\r\n\r\nMyApp.env.production?\r\n#=> false\r\n```\r\n\r\n#### Presence\r\n\r\nEnvironment inquirers can have explicit presence checks, circumventing a common pitfall when reasoning about environment variables. Borrowing from the example above:\r\n\r\n```ruby\r\nENV['STUB__AUTHENTICATION'] = 'false'\r\nclass MyApp\r\n  extend Inquisitive::Environment\r\n  inquires_about 'STUB'\r\nend\r\n\r\nMyApp.stub.authentication\r\n#=> \"false\"\r\nMyApp.stub.authentication?\r\n#=> true\r\nMyApp.stub.authentication.true?\r\n#=> false\r\n```\r\n\r\nIt's common to use the presence of environment variables as runtime booleans. This is frequently done by setting the environment variable to the string `\"true\"` when you want it to be true, and not at all otherwise. As demonstrated, this pattern can lead to ambiguity when the string is other values.\r\n\r\nBy default such variables will be parsed as an `Inquisitive::String`, so predicate methods will return true whatever their contents, as long as they exist. You can bind the predicate method tighter to an explicit value if you prefer:\r\n\r\n```ruby\r\nENV['STUB_AUTHENTICATION'] = 'false'\r\nENV['STUB_REGISTRATION']   = 'true'\r\nclass MyApp\r\n  extend Inquisitive::Environment\r\n  inquires_about 'STUB_AUTHENTICATION', present_if: 'true'\r\n  inquires_about 'STUB_REGISTRATION',   present_if: 'true'\r\nend\r\n\r\nMyApp.stub_authentication\r\n#=> \"false\"\r\nMyApp.stub_authentication?\r\n#=> false\r\n\r\nMyApp.stub_registration\r\n#=> \"true\"\r\nMyApp.stub_registration?\r\n#=> true\r\n```\r\n\r\nThis only works on top-level inquirers, so there's no way to get our nested `MyApp.stubbed.authentication?` to behave as expected. Prefer `MyApp.stubbed.authentication.true?` instead.\r\n\r\nThe `present_if` check uses `===` under the covers for maximum expressiveness, so you can also use it to match against regexs, classes, and other constructs.\r\n\r\n##### Truthy Strings\r\n\r\n`Inquisitive::Environment.truthy` contains a regex useful for trying to read truthy values from string environment variables.\r\n\r\n```ruby\r\nENV['NO']        = 'no'\r\nENV['YES']       = 'yes'\r\nENV['TRUTHY']    = 'TrUe'\r\nENV['FALSEY']    = 'FaLsE'\r\nENV['BOOLEAN']   = '1'\r\nENV['BOOLENOPE'] = '0'\r\nclass MyApp\r\n  extend Inquisitive::Environment\r\n  inquires_about 'NO',        present_if: truthy\r\n  inquires_about 'YES',       present_if: truthy\r\n  inquires_about 'TRUTHY',    present_if: truthy\r\n  inquires_about 'FALSEY',    present_if: truthy\r\n  inquires_about 'BOOLEAN',   present_if: truthy\r\n  inquires_about 'BOOLENOPE', present_if: truthy\r\nend\r\n\r\nMyApp.no?\r\n#=> false\r\nMyApp.yes?\r\n#=> true\r\n\r\nMyApp.truthy?\r\n#=> true\r\nMyApp.falsey?\r\n#=> false\r\n\r\nMyApp.boolean?\r\n#=> true\r\nMyApp.boolenope?\r\n#=> false\r\n```\r\n\r\n--------------------------------------------------------------------------------\r\n\r\nOrigins\r\n-------\r\n\r\nThe idea for Inquisitive originated with [this pull request](https://github.com/rails/rails/pull/12587), as I was going through a complicated Rails application and making it more 12-factor friendly by extracting much of the configuration into environment variables.\r\n\r\nBy the end of my effort, my configuration was substantially more *centralized* and *standardized*, but far more *complicated*. These complications arose in two places: adding, managing, permuting, and documenting my `.env` file consumed by [dotenv](https://github.com/bkeepers/dotenv); and organizing, parsing, and switching on those values injected into the `ENV`.\r\n\r\nMy pull request, and later Inquisitive, was extracted from my treatment of the latter complication. My solution to the former, [starenv](https://github.com/christhekeele/starenv), was a generally more complicated beast.\r\n\r\n--------------------------------------------------------------------------------\r\n\r\nContributing\r\n------------\r\n\r\n1. Fork it\r\n2. Create your feature branch (`git checkout -b my-new-feature`)\r\n3. Commit your changes (`git commit -am 'Add some feature'`)\r\n4. Push to the branch (`git push origin my-new-feature`)\r\n5. Create new Pull Request\r\n","google":"UA-52099551-1","note":"Don't delete this file! It's used internally to help with page regeneration."}