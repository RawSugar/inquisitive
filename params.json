{"name":"Inquisitive","tagline":"Predicate methods for those curious about their Ruby datastructures.","body":"Inquisitive\r\n===========\r\n\r\n> **Predicate methods for those curious about their datastructures.**\r\n\r\n\r\n\r\nSynopsis\r\n--------\r\n\r\nInquisitive provides String, Array, and Hash subclasses with dynamic predicate methods that allow you to interrogate the most common Ruby datastructures in a readable, friendly fashion. It's the inevitable evolution of ActiveSupport's `StringInquirer`.\r\n\r\nIt also allows you to auto-instanciate and read inquisitive datastructures straight from your `ENV` hash through the `Inquisitive::Environment` module.\r\n\r\nInquisitive will try to use ActiveSupport's `HashWithIndifferentAccess`, but if that cannot be found it will bootstrap itself with a minimal, well-tested version extracted from ActiveSupport 4.0.\r\n\r\n\r\n\r\nStatus\r\n------\r\n\r\n[status]:   https://travis-ci.org/christhekeele/inquisitive\r\n[coverage]: https://rawgit.com/christhekeele/inquisitive/master/coverage/index.html\r\n\r\n[version]:       https://rubygems.org/gems/inquisitive/versions\r\n[version-image]: https://badge.fury.io/rb/inquisitive@2x.svg\r\n\r\n[quality]:       https://codeclimate.com/github/christhekeele/inquisitive\r\n[quality-image]: https://img.shields.io/codeclimate/github/christhekeele/inquisitive.svg\r\n\r\n[dependencies]:       https://gemnasium.com/christhekeele/inquisitive\r\n[dependencies-image]: http://img.shields.io/gemnasium/christhekeele/inquisitive.svg\r\n\r\n[master]:          https://github.com/christhekeele/inquisitive/tree/master\r\n[master-status]:   https://img.shields.io/travis/christhekeele/inquisitive/master.svg\r\n[master-coverage]: https://img.shields.io/coveralls/christhekeele/inquisitive/master.svg\r\n\r\n[development]:          https://github.com/christhekeele/inquisitive/tree/development\r\n[development-status]:   https://img.shields.io/travis/christhekeele/inquisitive/development.svg\r\n[development-coverage]: https://img.shields.io/coveralls/christhekeele/inquisitive/development.svg\r\n\r\n[![Version][version-image]][version] [![Quality][quality-image]][quality] [![Dependencies][dependencies-image]][dependencies]\r\n\r\n|          :thumbsup:        |   [Continuous Integration][status]  |           [Test Coverage][coverage]      |\r\n|:--------------------------:|:-----------------------------------:|:----------------------------------------:|\r\n| [Master][master]           | ![Build Status][master-status]      | ![Coverage Status][master-coverage]      |\r\n| [Development][development] | ![Build Status][development-status] | ![Coverage Status][development-coverage] |\r\n\r\n\r\n\r\nInstallation\r\n------------\r\n\r\nTo add to your project:\r\n\r\n```bash\r\n$ echo \"gem 'inquisitive'\" >> Gemfile\r\n$ bundle install\r\n```\r\n\r\nOtherwise:\r\n\r\n```bash\r\n$ gem install inquisitive\r\n```\r\n\r\n\r\n\r\nUsage\r\n-----\r\n\r\n\r\n### String\r\n\r\n`Inquisitive::String` tests equality:\r\n\r\n```ruby\r\nenvironment = Inquisitive::String.new 'development'\r\n#=> \"development\"\r\nenvironment.development?\r\n#=> true\r\nenvironment.not.development?\r\n#=> false\r\n```\r\n\r\n\r\n### Array\r\n\r\n`Inquisitive::Array` tests inclusion:\r\n\r\n```ruby\r\nsupported_databases = Inquisitive::Array.new %w[mysql postgres sqlite]\r\n#=> [\"mysql\", \"postgres\", \"sqlite\"]\r\nsupported_databases.postgres?\r\n#=> true\r\nsupported_databases.sql_server?\r\n#=> false\r\nsupported_databases.exclude.sql_server?\r\n#=> true\r\n```\r\n\r\n\r\n### Hash\r\n\r\n`Inquisitive::Hash` provides struct-like access to its values, wrapped in other inquisitive objects:\r\n\r\n```ruby\r\nstubbed = Inquisitive::Hash.new(\r\n  authentication: true,\r\n  in: 'development',\r\n  services: %w[database api],\r\n  api: {protocol: 'https', subdomains: %w[app web db]},\r\n  ignorable: { junk: [ \"\" ] }\r\n)\r\n#=> {\"authentication\"=>true,\r\n#=>  \"in\"=>\"development\",\r\n#=>  \"services\"=>[\"database\", \"api\"],\r\n#=>  \"api\"=>{\"protocol\"=>\"https\", \"subdomains\"=>[\"app\", \"web\", \"db\"]},\r\n#=>  \"ignorable\"=>{\"junk\"=>[\"\"]}}\r\n\r\nstubbed.authentication?\r\n#=> true\r\nstubbed.registration?\r\n#=> false\r\nstubbed.services?\r\n#=> true\r\nstubbed.api?\r\n#=> true\r\nstubbed.ignorable?\r\n#=> false\r\n\r\nstubbed.in.development?\r\n#=> true\r\nstubbed.in.production?\r\n#=> false\r\n\r\nstubbed.services.database?\r\n#=> true\r\nstubbed.services.sidekiq?\r\n#=> false\r\n\r\nstubbed.api.protocol?\r\n#=> true\r\nstubbed.api.protocol.http?\r\n#=> false\r\nstubbed.api.domains.web?\r\n#=> true\r\n```\r\n\r\n`Inquisitive::Hash` also allows negation with the `no` method:\r\n\r\n```ruby\r\nconfig = Inquisitive::Hash.new(database: 'postgres')\r\n#=> {\"database\"=>\"postgres\"}\r\n\r\nconfig.database?\r\n#=> true\r\nconfig.no.database?\r\n#=> false\r\nconfig.api?\r\n#=> false\r\nconfig.no.api?\r\n#=> true\r\n```\r\n\r\nEmpty keys and nil values become instances of `Inquisitive::NilClass`, which is a black-hole null object that respects the Inquisitive interface, allowing you to inquire on non-existant nested datastructures as if there was one there, negated methods included:\r\n\r\n```ruby\r\nstubbed = Inquisitive::Hash.new\r\n#=> {}\r\n\r\n# We can query it as if we assumed we had:\r\n#=> {\"authentication\"=>true,\r\n#=>  \"in\"=>\"development\",\r\n#=>  \"services\"=>[\"database\", \"api\"],\r\n#=>  \"api\"=>{\"protocol\"=>\"https\", \"subdomains\"=>[\"app\", \"web\", \"db\"]}}\r\n\r\nstubbed.authentication?\r\n#=> false\r\nstubbed.registration?\r\n#=> false\r\nstubbed.services?\r\n#=> false\r\nstubbed.api?\r\n#=> false\r\nstubbed.ignorable?\r\n#=> false\r\nstubbed.no.ignorable?\r\n#=> true\r\n\r\nstubbed.in.development?\r\n#=> false\r\nstubbed.in.production?\r\n#=> false\r\nstubbed.in.not.production?\r\n#=> true\r\n\r\nstubbed.services.database?\r\n#=> false\r\nstubbed.services.sidekiq?\r\n#=> false\r\nstubbed.services.exclude.sidekiq?\r\n#=> true\r\n\r\nstubbed.api.protocol?\r\n#=> false\r\nstubbed.api.no.protocol?\r\n#=> true\r\nstubbed.api.protocol.http?\r\n#=> false\r\nstubbed.api.domains.web?\r\n#=> false\r\n```\r\n\r\n\r\n### Inquisitive Environment\r\n\r\n`Inquisitive::Environment` can be used in your modules and classes to more easily interrogate `ENV` variables with inquisitive objects:\r\n\r\n#### Strings\r\n\r\n```ruby\r\nENV['ENVIRONMENT'] = \"development\"\r\nclass MyApp\r\n  extend Inquisitive::Environment\r\n  inquires_about 'ENVIRONMENT'\r\nend\r\n\r\nMyApp.environment\r\n#=> \"development\"\r\nMyApp.environment.development?\r\n#=> true\r\nMyApp.environment.production?\r\n#=> false\r\n```\r\n\r\n#### Arrays\r\n\r\nArrays are recognized when environment variables contain commas:\r\n\r\n```ruby\r\nENV['SUPPORTED_DATABASES'] = \"mysql,postgres,sqlite\"\r\nclass MyApp\r\n  extend Inquisitive::Environment\r\n  inquires_about 'SUPPORTED_DATABASES'\r\nend\r\n\r\nMyApp.supported_databases\r\n#=> [\"mysql\", \"postgres\", \"sqlite\"]\r\nMyApp.supported_databases.sqlite?\r\n#=> true\r\nMyApp.supported_databases.sql_server?\r\n#=> false\r\n```\r\n\r\n#### Hashes\r\n\r\nHashes are recognized when environment variables names contain double underscores:\r\n\r\n```ruby\r\nENV['STUB__AUTHENTICATION'] = 'true'\r\nENV['STUB__IN'] = \"development\"\r\nENV['STUB__SERVICES'] = \"database,api\"\r\nENV['STUB__API__PROTOCOL'] = \"https\"\r\nENV['STUB__API__SUBDOMAINS'] = \"app,web,db\"\r\nclass MyApp\r\n  extend Inquisitive::Environment\r\n  inquires_about 'STUB'\r\nend\r\n\r\nMyApp.stub.authentication?\r\n#=> true\r\nMyApp.stub.registration?\r\n#=> false\r\nMyApp.stub.in.development?\r\n#=> true\r\nMyApp.stub.in.production?\r\n#=> false\r\nMyApp.stub.services.exclude.sidekiq?\r\n#=> true\r\nMyApp.stub.services.sidekiq?\r\n#=> false\r\nMyApp.stub.api.protocol.http?\r\n#=> false\r\nMyApp.stub.api.subdomains.web?\r\n#=> true\r\n```\r\n\r\n#### Naming\r\n\r\nYou can name your environment inquirers with `:with`:\r\n\r\n```ruby\r\nENV['ENVIRONMENT'] = \"development\"\r\nclass MyApp\r\n  extend Inquisitive::Environment\r\n  inquires_about 'ENVIRONMENT', with: :env\r\nend\r\n\r\nMyApp.env\r\n#=> \"development\"\r\nMyApp.env.development?\r\n#=> true\r\nMyApp.env.production?\r\n#=> false\r\n```\r\n\r\n#### Inquiry mode\r\n\r\nEnvironment inquirers have three configurable modes, defaulting to `:static`.\r\n\r\n```ruby\r\nclass MyApp\r\n  extend Inquisitive::Environment\r\n  inquires_about 'STUB', mode: %i[dynamic lazy static].sample\r\nend\r\n```\r\n\r\n- **Dynamic**\r\n\r\n    Environment inquiries parse `ENV` on every invocation.\r\n\r\n    Use if you're manipulating the environment in between invocations, so `Inquisitive` can pick up on new values, detect changes between string or array notation, and discover new keys for hash notation.\r\n\r\n- **Lazy**\r\n\r\n    Environment inquiries check `ENV` on their first invocation, and re-use the response in future invocations.\r\n\r\n    Use if you're loading the module with environment inquiry methods before you've finished preparing your environment.\r\n\r\n- **Static**\r\n\r\n    Environment inquiries use the contents of `ENV` at the moment `inquires_about` was invoked.\r\n\r\n    Use if your application is well-behaved and doesn't go mucking around with the environment at runtim.\r\n\r\n\r\n\r\nContributing\r\n------------\r\n\r\n1. Fork it\r\n2. Create your feature branch (`git checkout -b my-new-feature`)\r\n3. Commit your changes (`git commit -am 'Add some feature'`)\r\n4. Push to the branch (`git push origin my-new-feature`)\r\n5. Create new Pull Request\r\n","google":"UA-52099551-1","note":"Don't delete this file! It's used internally to help with page regeneration."}