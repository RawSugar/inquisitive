{"name":"Inquisitive","tagline":"Predicate methods for those curious about their Ruby datastructures.","body":"Inquisitive\r\n===========\r\n\r\n> **Predicate methods for those curious about their datastructures.**\r\n\r\nInquisitive provides String, Array, and Hash subclasses with dynamic predicate methods that allow you to interrogate the most common Ruby datastructures in a readable, friendly fashion. It's the inevitable evolution of ActiveSupport's `StringInquirer`.\r\n\r\nIt also allows you to auto-instanciate and read inquisitive datastructures straight from your `ENV` hash through the `Inquisitive::Environment` module.\r\n\r\nInquisitive will try to use ActiveSupport's `HashWithIndifferentAccess`, but if that cannot be found it will bootstrap itself with a minimal, well-tested version extracted from ActiveSupport 4.0.\r\n\r\nInstallation\r\n------------\r\n\r\nTo add to your project:\r\n\r\n```bash\r\n$ echo \"gem 'inquisitive'\" >> Gemfile\r\n$ bundle install\r\n```\r\n\r\nOtherwise:\r\n\r\n```bash\r\n$ gem install inquisitive\r\n```\r\n\r\nUsage\r\n-----\r\n\r\n### String\r\n\r\n`Inquisitive::String` tests equality:\r\n\r\n```ruby\r\nenvironment = Inquisitive::String.new 'development'\r\n#=> \"development\"\r\nenvironment.development?\r\n#=> true\r\nenvironment.not.development?\r\n#=> false\r\n```\r\n\r\n### Array\r\n\r\n`Inquisitive::Array` tests inclusion:\r\n\r\n```ruby\r\nsupported_databases = Inquisitive::Array.new %w[mysql postgres sqlite]\r\n#=> [\"mysql\", \"postgres\", \"sqlite\"]\r\nsupported_databases.postgres?\r\n#=> true\r\nsupported_databases.sql_server?\r\n#=> false\r\nsupported_databases.exclude.sql_server?\r\n#=> true\r\n```\r\n\r\n### Hash\r\n\r\n`Inquisitive::Hash` provides struct-like access to its values, wrapped in other inquisitive objects:\r\n\r\n```ruby\r\nstubbed = Inquisitive::Hash.new(\r\n  authentication: true,\r\n  in: 'development',\r\n  services: %w[database api],\r\n  ignorable: { junk: [ \"\" ] }\r\n)\r\n#=> {\"authentication\"=>true,\r\n#=>  \"in\"=>\"development\",\r\n#=>  \"services\"=>[\"database\", \"api\"],\r\n#=>  \"ignorable\"=>{\"junk\"=>[\"\"]}}\r\n\r\nstubbed.authentication?\r\n#=> true\r\nstubbed.registration?\r\n#=> false\r\nstubbed.services?\r\n#=> true\r\nstubbed.ignorable?\r\n#=> false\r\n\r\nstubbed.in.development?\r\n#=> true\r\nstubbed.in.production?\r\n#=> false\r\nstubbed.services.database?\r\n#=> true\r\nstubbed.services.sidekiq?\r\n#=> false\r\n```\r\n\r\n`Inquisitive::Hash` also allows negation with the `no` method:\r\n\r\n```ruby\r\nconfig = Inquisitive::Hash.new(database: 'postgres')\r\n#=> {\"database\"=>\"postgres\"}\r\n\r\nconfig.database?\r\n#=> true\r\nconfig.no.database?\r\n#=> false\r\nconfig.api?\r\n#=> false\r\nconfig.no.api?\r\n#=> true\r\n```\r\n\r\n### Inquisitive Environment\r\n\r\n`Inquisitive::Environment` can be used in your modules and classes to more easily interrogate `ENV` variables with inquisitive objects:\r\n\r\n#### Strings\r\n\r\n```ruby\r\nENV['ENVIRONMENT'] = \"development\"\r\nclass MyGame\r\n  extend Inquisitive::Environment\r\n  inquires_about 'ENVIRONMENT'\r\nend\r\n\r\nMyGame.environment\r\n#=> \"development\"\r\nMyGame.environment.development?\r\n#=> true\r\nMyGame.environment.production?\r\n#=> false\r\n```\r\n\r\n#### Arrays\r\n\r\n```ruby\r\nENV['SUPPORTED_DATABASES'] = \"mysql,postgres,sqlite\"\r\nclass MyGame\r\n  extend Inquisitive::Environment\r\n  inquires_about 'SUPPORTED_DATABASES'\r\nend\r\n\r\nMyGame.supported_databases\r\n#=> [\"mysql\", \"postgres\", \"sqlite\"]\r\nMyGame.supported_databases.sqlite?\r\n#=> true\r\nMyGame.supported_databases.sql_server?\r\n#=> false\r\n```\r\n\r\n#### Hashes\r\n\r\n```ruby\r\nENV['STUB__AUTHENTICATION'] = 'true'\r\nENV['STUB__IN'] = \"development\"\r\nENV['STUB__SERVICES'] = \"database,api\"\r\nclass MyGame\r\n  extend Inquisitive::Environment\r\n  inquires_about 'STUB'\r\nend\r\n\r\nMyGame.stub.authentication?\r\n#=> true\r\nMyGame.stub.registration?\r\n#=> false\r\nMyGame.stub.in.development?\r\n#=> true\r\nMyGame.stub.in.production?\r\n#=> false\r\nMyGame.stub.services.exclude.sidekiq?\r\n#=> true\r\nMyGame.stub.services.sidekiq?\r\n#=> false\r\n```\r\n\r\n#### Naming\r\n\r\nYou can name your environment inquirers with `:with`:\r\n\r\n```ruby\r\nENV['ENVIRONMENT'] = \"development\"\r\nclass MyGame\r\n  extend Inquisitive::Environment\r\n  inquires_about 'ENVIRONMENT', with: :env\r\nend\r\n\r\nMyGame.env\r\n#=> \"development\"\r\nMyGame.env.development?\r\n#=> true\r\nMyGame.env.production?\r\n#=> false\r\n```\r\n\r\n#### Presence\r\n\r\nEnvironment inquirers can have explicit presence checks, circumventing a common pitfall when reasoning about environment variables. Borrowing from the example above:\r\n\r\n```ruby\r\nENV['STUB__AUTHENTICATION'] = 'false'\r\nclass MyGame\r\n  extend Inquisitive::Environment\r\n  inquires_about 'STUB'\r\nend\r\n\r\nMyGame.stub.authentication\r\n#=> \"false\"\r\nMyGame.stub.authentication?\r\n#=> true\r\nMyGame.stub.authentication.true?\r\n#=> false\r\n```\r\n\r\nIt's common to use the presence of environment variables as runtime booleans. This is frequently done by setting the environment variable to the string `\"true\"` when you want it to be true, and not at all otherwise. As demonstrated, this pattern can lead to ambiguity when the string is other values.\r\n\r\nBy default such variables will be parsed as an `Inquisitive::String`, so predicate methods will return true whatever their contents, as long as they exist. You can bind the predicate method tighter to an explicit value if you prefer:\r\n\r\n```ruby\r\nENV['STUB_AUTHENTICATION'] = 'false'\r\nENV['STUB_REGISTRATION'] = 'true'\r\nclass MyGame\r\n  extend Inquisitive::Environment\r\n  inquires_about 'STUB_AUTHENTICATION', present_if: 'true'\r\n  inquires_about 'STUB_REGISTRATION', present_if: 'true'\r\nend\r\n\r\nMyGame.stub_authentication\r\n#=> \"false\"\r\nMyGame.stub_authentication?\r\n#=> false\r\n\r\nMyGame.stub_registration\r\n#=> \"true\"\r\nMyGame.stub_registration?\r\n#=> true\r\n```\r\n\r\nThis only works on top-level inquirers, so there's no way to get our nested `MyGame.stubbed.authentication?` to behave as expected (currently).\r\n\r\nThe `present_if` check uses `===` under the covers for maximum expressiveness, so you can also use it to match against regexs, classes, and other constructs.\r\n\r\n#### Inquiry mode\r\n\r\nEnvironment inquirers have three configurable modes, defaulting to `:static`.\r\n\r\n```ruby\r\nclass MyGame\r\n  extend Inquisitive::Environment\r\n  inquires_about 'STUB', mode: %i[dynamic lazy static].sample\r\nend\r\n```\r\n\r\n- **Dynamic**\r\n\r\n    Environment inquiries parse `ENV` on every invocation.\r\n\r\n    Use if you're manipulating the environment in between invocations, so `Inquisitive` can pick up on new values, detect changes between string or array notation, and discover new keys for hash notation.\r\n\r\n- **Lazy**\r\n\r\n    Environment inquiries check `ENV` on their first invocation, and re-use the response in future invocations.\r\n\r\n    Use if you're loading the module with environment inquiry methods before you've finished preparing your environment.\r\n\r\n- **Static**\r\n\r\n    Environment inquiries use the contents of `ENV` at the moment `inquires_about` was invoked.\r\n\r\n    Use if your application is well-behaved and doesn't go mucking around with the environment at runtime.\r\n\r\nContributing\r\n------------\r\n\r\n1. Fork it\r\n2. Create your feature branch (`git checkout -b my-new-feature`)\r\n3. Commit your changes (`git commit -am 'Add some feature'`)\r\n4. Push to the branch (`git push origin my-new-feature`)\r\n5. Create new Pull Request\r\n","google":"UA-52099551-1","note":"Don't delete this file! It's used internally to help with page regeneration."}